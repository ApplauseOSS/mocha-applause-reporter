{"version":3,"file":"index.min.js","sources":["../src/index.ts","../src/hooks.ts"],"sourcesContent":["import { reporters } from 'mocha';\n\nimport {\n  ApplauseReporter,\n  TestResultStatus,\n  loadConfig,\n} from 'applause-reporter-common';\nimport { Runner } from 'mocha';\nimport { Test } from 'mocha';\nimport { SESSION_ID_EVENT } from './hooks.ts';\n\nexport default class ApplauseMochaReporter extends reporters.Base {\n  private reporter: ApplauseReporter;\n  private sessionIdMap: Map<string, string[]> = new Map();\n\n  constructor(runner: Runner) {\n    super(runner);\n    const config = loadConfig();\n    this.reporter = new ApplauseReporter(config);\n\n    runner.once(Runner.constants.EVENT_SUITE_BEGIN, suite => {\n      // Parse each test case name from the suite\n      const tests: string[] = [];\n      suite.eachTest(t => tests.push(t.fullTitle()));\n      void this.reporter.runnerStart(tests);\n    });\n    /*\n     * make reporter to write to the output stream by default\n     */\n    runner\n      .on(Runner.constants.EVENT_TEST_BEGIN, (testcase: Test) => {\n        this.listenToSessionId(testcase);\n        void this.reporter.startTestCase(testcase.id, testcase.fullTitle());\n      })\n      .on(Runner.constants.EVENT_TEST_PASS, (testcase: Test) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.PASSED,\n          { providerSessionGuids: this.sessionIdMap.get(testcase.id) || [] }\n        );\n      })\n      .on(Runner.constants.EVENT_TEST_PENDING, (testcase: Test) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.SKIPPED,\n          { providerSessionGuids: this.sessionIdMap.get(testcase.id) || [] }\n        );\n      })\n      .on(Runner.constants.EVENT_TEST_FAIL, (testcase: Test, error: Error) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.FAILED,\n          {\n            failureReason: error.message,\n            providerSessionGuids: this.sessionIdMap.get(testcase.id) || [],\n          }\n        );\n      })\n      .once(Runner.constants.EVENT_RUN_END, () => {\n        void this.reporter.runnerEnd();\n      });\n  }\n\n  private recordSessionId(id: string, sessionId: string) {\n    this.sessionIdMap.set(id, [\n      ...(this.sessionIdMap.get(id) || []),\n      sessionId,\n    ]);\n  }\n\n  private listenToSessionId(test: Test): void {\n    test.on(SESSION_ID_EVENT, (sessionId: string) =>\n      this.recordSessionId(test.id, sessionId)\n    );\n  }\n}\n","import { Hook, Test } from 'mocha';\n\nexport const SESSION_ID_EVENT = 'applause-session-id-register';\n\nexport function registerSessionIdHook(\n  sessionIdLookup: () => string | undefined\n) {\n  return function (this: Mocha.Context) {\n    if (\n      this.test instanceof Hook &&\n      !this.test.title.startsWith('\"before each\"')\n    ) {\n      console.warn('Can only register session id in the beforeEach hook');\n      return;\n    }\n    registerSessionId.apply(this, [sessionIdLookup()]);\n  };\n}\n\nexport function registerSessionId(\n  this: Mocha.Context,\n  sessionId: string | undefined\n) {\n  // this: Mocha.Context can be executed for either a Hook for a test. If this is being executed for a Hook,\n  // we want to emit the event on the currentTest, not the test (which is actually the hook)\n  if (this.test instanceof Test) {\n    this.test?.emit(SESSION_ID_EVENT, sessionId);\n  } else if (this.test instanceof Hook && this.currentTest instanceof Test) {\n    this.currentTest?.emit(SESSION_ID_EVENT, sessionId);\n  }\n}\n"],"names":["ApplauseMochaReporter","reporters","Base","reporter","sessionIdMap","Map","constructor","runner","super","config","loadConfig","this","ApplauseReporter","once","Runner","constants","EVENT_SUITE_BEGIN","suite","tests","eachTest","t","push","fullTitle","runnerStart","on","EVENT_TEST_BEGIN","testcase","listenToSessionId","startTestCase","id","EVENT_TEST_PASS","submitTestCaseResult","TestResultStatus","PASSED","providerSessionGuids","get","EVENT_TEST_PENDING","SKIPPED","EVENT_TEST_FAIL","error","FAILED","failureReason","message","EVENT_RUN_END","runnerEnd","recordSessionId","sessionId","set","test"],"mappings":"uXAWc,MAAOA,UAA8BC,EAASA,UAACC,KACnDC,SACAC,aAAsC,IAAIC,IAElD,WAAAC,CAAYC,GACVC,MAAMD,GACN,MAAME,EAASC,EAAAA,aACfC,KAAKR,SAAW,IAAIS,EAAgBA,iBAACH,GAErCF,EAAOM,KAAKC,EAAAA,OAAOC,UAAUC,mBAAmBC,IAE9C,MAAMC,EAAkB,GACxBD,EAAME,UAASC,GAAKF,EAAMG,KAAKD,EAAEE,eAC5BX,KAAKR,SAASoB,YAAYL,MAKjCX,EACGiB,GAAGV,EAAAA,OAAOC,UAAUU,kBAAmBC,IACtCf,KAAKgB,kBAAkBD,GAClBf,KAAKR,SAASyB,cAAcF,EAASG,GAAIH,EAASJ,gBAExDE,GAAGV,EAAAA,OAAOC,UAAUe,iBAAkBJ,IAChCf,KAAKR,SAAS4B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACC,OACjB,CAAEC,qBAAsBvB,KAAKP,aAAa+B,IAAIT,EAASG,KAAO,QAGjEL,GAAGV,EAAAA,OAAOC,UAAUqB,oBAAqBV,IACnCf,KAAKR,SAAS4B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACK,QACjB,CAAEH,qBAAsBvB,KAAKP,aAAa+B,IAAIT,EAASG,KAAO,QAGjEL,GAAGV,EAAMA,OAACC,UAAUuB,iBAAiB,CAACZ,EAAgBa,KAChD5B,KAAKR,SAAS4B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACQ,OACjB,CACEC,cAAeF,EAAMG,QACrBR,qBAAsBvB,KAAKP,aAAa+B,IAAIT,EAASG,KAAO,QAIjEhB,KAAKC,EAAMA,OAACC,UAAU4B,eAAe,KAC/BhC,KAAKR,SAASyC,cAExB,CAEO,eAAAC,CAAgBhB,EAAYiB,GAClCnC,KAAKP,aAAa2C,IAAIlB,EAAI,IACpBlB,KAAKP,aAAa+B,IAAIN,IAAO,GACjCiB,GAEH,CAEO,iBAAAnB,CAAkBqB,GACxBA,EAAKxB,GCrEuB,gCDqEDsB,GACzBnC,KAAKkC,gBAAgBG,EAAKnB,GAAIiB,IAEjC"}