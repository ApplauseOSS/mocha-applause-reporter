{"version":3,"file":"index.min.js","sources":["../src/hooks.ts","../src/index.ts"],"sourcesContent":["import { Hook, Test } from 'mocha';\n\nexport const SESSION_ID_EVENT = 'applause-session-id-register';\n\nexport function registerSessionIdHook(\n  sessionIdLookup: () => string | undefined\n) {\n  return function (this: Mocha.Context) {\n    if (\n      this.test instanceof Hook &&\n      !this.test.title.startsWith('\"before each\"')\n    ) {\n      console.warn('Can only register session id in the beforeEach hook');\n      return;\n    }\n    registerSessionId.apply(this, [sessionIdLookup()]);\n  };\n}\n\nexport function registerSessionId(\n  this: Mocha.Context,\n  sessionId: string | undefined\n) {\n  // this: Mocha.Context can be executed for either a Hook for a test. If this is being executed for a Hook,\n  // we want to emit the event on the currentTest, not the test (which is actually the hook)\n  if (this.test instanceof Test) {\n    this.test?.emit(SESSION_ID_EVENT, sessionId);\n  } else if (this.test instanceof Hook && this.currentTest instanceof Test) {\n    this.currentTest?.emit(SESSION_ID_EVENT, sessionId);\n  }\n}\n","import { reporters } from 'mocha';\n\nimport {\n  ApplauseReporter,\n  TestResultStatus,\n  loadConfig,\n} from 'applause-reporter-common';\nimport { Runner } from 'mocha';\nimport { Test } from 'mocha';\nimport { SESSION_ID_EVENT } from './hooks.ts';\n\nexport default class ApplauseMochaReporter extends reporters.Base {\n  private reporter: ApplauseReporter;\n  private sessionIdMap: Map<string, string[]> = new Map();\n\n  constructor(runner: Runner) {\n    super(runner);\n    const config = loadConfig();\n    this.reporter = new ApplauseReporter(config);\n\n    runner.once(Runner.constants.EVENT_SUITE_BEGIN, suite => {\n      // Parse each test case name from the suite\n      const tests: string[] = [];\n      suite.eachTest(t => tests.push(t.fullTitle()));\n      void this.reporter.runnerStart(tests);\n    });\n    /*\n     * make reporter to write to the output stream by default\n     */\n    runner\n      .on(Runner.constants.EVENT_TEST_BEGIN, (testcase: Test) => {\n        this.listenToSessionId(testcase);\n        void this.reporter.startTestCase(testcase.id, testcase.fullTitle());\n      })\n      .on(Runner.constants.EVENT_TEST_PASS, (testcase: Test) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.PASSED,\n          { providerSessionGuids: this.sessionIdMap.get(testcase.id) || [] }\n        );\n      })\n      .on(Runner.constants.EVENT_TEST_PENDING, (testcase: Test) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.SKIPPED,\n          { providerSessionGuids: this.sessionIdMap.get(testcase.id) || [] }\n        );\n      })\n      .on(Runner.constants.EVENT_TEST_FAIL, (testcase: Test, error: Error) => {\n        void this.reporter.submitTestCaseResult(\n          testcase.id,\n          TestResultStatus.FAILED,\n          {\n            failureReason: error.message,\n            providerSessionGuids: this.sessionIdMap.get(testcase.id) || [],\n          }\n        );\n      })\n      .once(Runner.constants.EVENT_RUN_END, () => {\n        void this.reporter.runnerEnd();\n      });\n  }\n\n  private recordSessionId(id: string, sessionId: string) {\n    this.sessionIdMap.set(id, [\n      ...(this.sessionIdMap.get(id) || []),\n      sessionId,\n    ]);\n  }\n\n  private listenToSessionId(test: Test): void {\n    test.on(SESSION_ID_EVENT, (sessionId: string) =>\n      this.recordSessionId(test.id, sessionId)\n    );\n  }\n}\n\nexport * from './hooks.ts';\n"],"names":["SESSION_ID_EVENT","registerSessionId","sessionId","this","test","Test","emit","Hook","currentTest","ApplauseMochaReporter","reporters","Base","reporter","sessionIdMap","Map","constructor","runner","super","config","loadConfig","ApplauseReporter","once","Runner","constants","EVENT_SUITE_BEGIN","suite","tests","eachTest","t","push","fullTitle","runnerStart","on","EVENT_TEST_BEGIN","testcase","listenToSessionId","startTestCase","id","EVENT_TEST_PASS","submitTestCaseResult","TestResultStatus","PASSED","providerSessionGuids","get","EVENT_TEST_PENDING","SKIPPED","EVENT_TEST_FAIL","error","FAILED","failureReason","message","EVENT_RUN_END","runnerEnd","recordSessionId","set","sessionIdLookup","title","startsWith","console","warn","apply"],"mappings":"+XAEa,MAAAA,EAAmB,+BAiB1B,SAAUC,EAEdC,GAIIC,KAAKC,gBAAgBC,OACvBF,KAAKC,MAAME,KAAKN,EAAkBE,GACzBC,KAAKC,gBAAgBG,EAAAA,MAAQJ,KAAKK,uBAAuBH,EAAAA,MAClEF,KAAKK,aAAaF,KAAKN,EAAkBE,EAE7C,CCnBc,MAAOO,UAA8BC,EAASA,UAACC,KACnDC,SACAC,aAAsC,IAAIC,IAElD,WAAAC,CAAYC,GACVC,MAAMD,GACN,MAAME,EAASC,EAAAA,aACfhB,KAAKS,SAAW,IAAIQ,EAAgBA,iBAACF,GAErCF,EAAOK,KAAKC,EAAAA,OAAOC,UAAUC,mBAAmBC,IAE9C,MAAMC,EAAkB,GACxBD,EAAME,UAASC,GAAKF,EAAMG,KAAKD,EAAEE,eAC5B3B,KAAKS,SAASmB,YAAYL,EAAM,IAKvCV,EACGgB,GAAGV,EAAAA,OAAOC,UAAUU,kBAAmBC,IACtC/B,KAAKgC,kBAAkBD,GAClB/B,KAAKS,SAASwB,cAAcF,EAASG,GAAIH,EAASJ,YAAY,IAEpEE,GAAGV,EAAAA,OAAOC,UAAUe,iBAAkBJ,IAChC/B,KAAKS,SAAS2B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACC,OACjB,CAAEC,qBAAsBvC,KAAKU,aAAa8B,IAAIT,EAASG,KAAO,IAC/D,IAEFL,GAAGV,EAAAA,OAAOC,UAAUqB,oBAAqBV,IACnC/B,KAAKS,SAAS2B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACK,QACjB,CAAEH,qBAAsBvC,KAAKU,aAAa8B,IAAIT,EAASG,KAAO,IAC/D,IAEFL,GAAGV,EAAMA,OAACC,UAAUuB,iBAAiB,CAACZ,EAAgBa,KAChD5C,KAAKS,SAAS2B,qBACjBL,EAASG,GACTG,EAAgBA,iBAACQ,OACjB,CACEC,cAAeF,EAAMG,QACrBR,qBAAsBvC,KAAKU,aAAa8B,IAAIT,EAASG,KAAO,IAE/D,IAEFhB,KAAKC,EAAMA,OAACC,UAAU4B,eAAe,KAC/BhD,KAAKS,SAASwC,WAAW,GAEnC,CAEO,eAAAC,CAAgBhB,EAAYnC,GAClCC,KAAKU,aAAayC,IAAIjB,EAAI,IACpBlC,KAAKU,aAAa8B,IAAIN,IAAO,GACjCnC,GAEH,CAEO,iBAAAiC,CAAkB/B,GACxBA,EAAK4B,GAAGhC,GAAmBE,GACzBC,KAAKkD,gBAAgBjD,EAAKiC,GAAInC,IAEjC,iFDtEG,SACJqD,GAEA,OAAO,WAEHpD,KAAKC,gBAAgBG,EAAIA,OACxBJ,KAAKC,KAAKoD,MAAMC,WAAW,iBAE5BC,QAAQC,KAAK,uDAGf1D,EAAkB2D,MAAMzD,KAAM,CAACoD,KACjC,CACF"}